# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Remove unneeded fields from derep object(s)
#' @param derep (`list`) [`derep`][dada2::derep-class] object, or possibly
#' nested list of such objects
#' @return None. This function is called for its side effect, which is to
#' remove the `uniques` and `quals` fields from the input object
#' @export
derep_map_only <- function(derep) {
    invisible(.Call(`_optimotu_pipeline_derep_map_only`, derep))
}

#' Calculate empirical transition matrix from known true sequences
#'
#' @param true_seq (`character`) Vector of true sequences
#' @param obs_seq (`character`) Vector of observed reads
#' @param obs_qual (`character`) Vector of quality scores for observed reads
#' @param match_idx (`integer`) Indices of the true sequences that match each
#' observed read
#' @param cigar (`character`) CIGAR strings for alignment between each
#' observed read and its corresponding true sequence
#' @param scores (`integer`) set of unique quality scores found in the
#' observed reads
#' @param indel (`logical`) Whether to include indels in the transition
#' matrix
#'
#' Calculates an empirical translation matrix based on pairwise alignments
#' between true sequences (e.g., from a positive control or mock community)
#' and observed reads. In the case of substitutions (i.e., matches and
#' mismatches), there are 16 possible transitions (4 bases each for the true
#' base and the observed base), each of which is represented as one row in the
#' resulting matrix. The rownames are of the form "X2Y", representing
#' "observed cases where X in the true sequence was observed as Y in a read",
#' where both X and Y are "A", "C", "G", or "T". The columns represent the
#' quality scores of the base in the reads.
#'
#' If `indel = TRUE`, the matrix will also include transitions for insertions
#' and deletions. Because each of these represents a lack of correspondence
#' between the true sequence and the observed read, there is some ambiguity
#' in exactly how they should be mapped.
#'
#' For insertions, the inserted base(s) have no corresponding element in the
#' true sequence, but may in theory be mapped to either the previous base or
#' the next base in the true sequence. The matrix includes two rows for
#' these, with names of the form "X_2NY", and "_X2YN", meaning "The position
#' after X in the true sequence had an observed insertion of Y" and "The
#' position before X in the true sequence had an observed insertion of Y",
#' respectively. "N" in this case symbolizes "any base in the position of X",
#' because it is possible that the insertion is directly preceded or followed
#' by a substitution. The column for the insertion is the quality score of the
#' inserted base (i.e., "Y").
#'
#' For deletions, it is clear which base in the true sequence was deleted, but
#' the quality score of the deleted base is not available; however it is
#' expected that the quality score of the preceding or following base might be
#' indicative of the possible presence of a deletion. Thus each deletion
#' occurs twice in the matrix, once for each of the two possible quality
#' scores. The row names for these are "XN2_N" and "NX2N_", meaning in both
#' cases "X in the true sequence was deleted in the observed sequence"; the
#' "N" is a placeholder for the base in the observed sequence that supplies
#' the quality score for the deletion.
#'
#' @return An integer matrix with rows representing transitions from one base
#' to another (or to an insertion or deletion when `indel = TRUE`), columns
#' representing quality scores, and values representing the count of each
#' transition.
#'
#' @export
empirical_transition_matrix <- function(true_seq, obs_seq, obs_qual, match_idx, cigar, scores, indel = FALSE) {
    .Call(`_optimotu_pipeline_empirical_transition_matrix`, true_seq, obs_seq, obs_qual, match_idx, cigar, scores, indel)
}

#' Convert a multiline FASTA file into a single-line FASTA file
#'
#' @param infile (`character(1)`) FASTA file, can be compressed
#' @param outfile (`character(1)`) name of output FASTA file
#' @param compress (`logical(1)`) compress output file
#' @return `character(1)` output file name
#' @export
fasta_deline <- function(infile, outfile, compress = FALSE) {
    .Call(`_optimotu_pipeline_fasta_deline`, infile, outfile, compress)
}

#' Flag the fate of reads from a FASTQ file through processing stages
#' @param raw (`character`) FASTQ file path, optionally gzipped. The raw reads.
#' @param stages (`character`) FASTQ file paths, optionally gzipped. The
#' processed reads after multiple ordered stages.
#' @return a `data.frame` with columns `read_idx` (`integer`) and `flags`
#' (`raw`) indicating which processing stages each read was found in.
#' @export
fastq_stage_flags <- function(raw, stages) {
    .Call(`_optimotu_pipeline_fastq_stage_flags`, raw, stages)
}

#' @rdname fastq_stage_flags
#' @param stage1 (`character`) FASTQ file path, optionally gzipped, the first
#' processed stage
#' @param stage2 (`character`) FASTQ file path, optionally gzipped, the second
#' processed stage
#' @export
fastq_stage_flag2 <- function(raw, stage1, stage2) {
    .Call(`_optimotu_pipeline_fastq_stage_flag2`, raw, stage1, stage2)
}

#' Map reads from a FASTQ file to processing stages
#' @param raw (`character`) FASTQ file path, optionally gzipped. The raw reads.
#' @param stages (`character`) FASTQ file paths, optionally gzipped. The
#' processed reads after multiple ordered stages.
#' @return a `data.frame` with columns `read_idx` (`integer`) and `flags`
#' (`raw`) indicating which processing stages each read was found in.
#' @export
fastq_stage_map <- function(raw, stages) {
    .Call(`_optimotu_pipeline_fastq_stage_map`, raw, stages)
}

#' Map the fate of individual reads through trimming and filtering steps
#' @param fq_raw (`character`) raw FASTQ file path, optionally gzipped
#' @param fq_trim (`character`) trimmed FASTQ file path, optionally gzipped
#' @param fq_filt (`character`) filtered FASTQ file path, optionally gzipped
#' @return `data.frame` with columns:
#' - `raw_idx` (integer) index of the sequence in fastq_raw; or if sequence names
#' in the fastq files are hex encoded integers (e.g., during subsampling to
#' indicate the original index) then `seq_id` comes from the sequence names.
#' - `trim_idx` (integer) index of the sequence in fastq_trim, or NA if absent
#' - `filt_idx` (integer) index of the sequence in fastq_filt, or NA if absent
#' @export
fastq_seq_map <- function(fq_raw, fq_trim, fq_filt) {
    .Call(`_optimotu_pipeline_fastq_seq_map`, fq_raw, fq_trim, fq_filt)
}

#' Get the names of reads in a FASTQ file
#' @param x (`character`) FASTQ file path, optionally gzipped.
#' @return (`character`) Read names.
#' @export
fastq_names <- function(x) {
    .Call(`_optimotu_pipeline_fastq_names`, x)
}

#' Get the unique quality scores in a set of FASTQ files
#' @param fastq (`character`) FASTQ file paths, optionally gzipped.
#' @param max_n (`integer`) Maximum number of reads to process.
#' @param offset (`integer`) ASCII offset for quality scores.
#' @return (`integer`) Unique quality scores.
#' @export
fastq_qual_bins <- function(fastq, max_n = 1e9L, offset = 33L) {
    .Call(`_optimotu_pipeline_fastq_qual_bins`, fastq, max_n, offset)
}

#' Subsample from a FASTQ file
#'
#' This function subsamples an (optionally gzipped) FASTQ file by randomly
#' selecting a specified number of reads. The file is streamed and only
#' `denominator` reads are stored in memory at any time, which allows it to
#' handle very large files without running out of memory. Sampling is
#' performed with reservoir sampling.
#'
#' Additionally, it guarantees that, if the same file is resampled with the
#' same seed, but a larger number of reads, the result from the first sampling
#' will be a subset of the new, larger sampling.
#'
#' When the number of sequences in the input file is not divisible by the
#' denominator, the remainder sequences will be sampled as if there were enough
#' additional sequences to fill the denominator, so that the actual number of
#' sampled sequences may differ from (file size) * `numerator` / `denominator`
#' by up to max(`numerator`, `denominator`/2).
#'
#' @param file (`character` string) the path to the FASTQ file.
#' @param numerator (`integer` scalar) numerator of the fraction of reads to
#' sample.
#' @param denominator (`integer` scalar) denominator of the fraction of reads
#' to sample.
#' @param output (`character` string) the path to the output file. If it ends
#' in ".gz", the output will be gzipped.
#' @param rename (`logical` scalar) whether to rename the reads in the output;
#' if `TRUE`, the read names will be replaced with a hexadecimal sequential
#' number
#'
#' @return the output file name
#' @export
fastq_sample_fraction <- function(file, numerator, denominator, output, rename = FALSE) {
    .Call(`_optimotu_pipeline_fastq_sample_fraction`, file, numerator, denominator, output, rename)
}

#' Take multiple samples from a FASTQ file
#'
#' This function takes multiple samples from a FASTQ file using the same
#' denomerator and seed, but different numerators.
#'
#' @param file (`character` string) the path to the input FASTQ file.
#' @param numerators (`integer` vector) a vector of numerators for the
#' fractions of reads to sample.
#' @param denominator (`integer` scalar) the denominator of the fraction of
#' reads to sample.
#' @param output (`character` vector) a vector of output file names. If an
#' element ends in ".gz", the output will be gzipped.
#'
#' @return a character vector of output file names
#' @export
fastq_sample_fraction_multiple <- function(file, numerators, denominator, output, rename = FALSE) {
    .Call(`_optimotu_pipeline_fastq_sample_fraction_multiple`, file, numerators, denominator, output, rename)
}

#' Subsample a FASTQ file to a fixed number of reads
#'
#' This function subsamples a FASTQ file to a fixed number of reads.
#'
#' @param file (`character` string) the path to the input FASTQ file. May be gzipped.
#' @param number (`integer` scalar) the number of reads to sample.
#' @param output (`character` string) the path to the output file. If it ends in ".gz", the output will be gzipped.
#' @param rename (`logical` scalar) whether to rename the reads in the output;
#' if `TRUE`, the read names will be replaced with a hexadecimal sequential
#' number
#'
#' @return the output file name
#' @export
fastq_sample_number <- function(file, number, output, rename = FALSE) {
    .Call(`_optimotu_pipeline_fastq_sample_number`, file, number, output, rename)
}

#' Subsample a FASTQ file to multiple numbers of reads
#'
#' This function subsamples a FASTQ file to multiple numbers of reads.
#'
#' @param file (`character` string) the path to the input FASTQ file. May be gzipped.
#' @param numbers (`integer` vector) the numbers of reads to sample.
#' @param output (`character` vector) a vector of output file names. If an
#' element ends in ".gz", the output will be gzipped.
#' @param rename (`logical` scalar) whether to rename the reads in the output;
#' if `TRUE`, the read names will be replaced with a hexadecimal sequential
#' number.
#'
#' @return a character vector of output file names
#' @export
fastq_sample_number_multiple <- function(file, numbers, output, rename = FALSE) {
    .Call(`_optimotu_pipeline_fastq_sample_number_multiple`, file, numbers, output, rename)
}

#' Interleave multiple FASTQ files
#' @param infiles (`character()`) input FASTQ files, can be compressed
#' @param outfile (`character(1)`) output FASTQ file
#' @param compress (`logical(1)`) compress output file
#' @return `character(1)` output file name
#' @export
#' @keywords internal
fastq_combine <- function(infiles, outfile, compress = FALSE) {
    .Call(`_optimotu_pipeline_fastq_combine`, infiles, outfile, compress)
}

#' Interleave multiple FASTA files
#' @param infiles (`character()`) input FASTA files, can be compressed
#' @param outfile (`character(1)`) output FASTA file
#' @param compress (`logical(1)`) compress output file
#' @return `character(1)` output file name
#' @export
#' @keywords internal
fasta_combine <- function(infiles, outfile, compress = FALSE) {
    .Call(`_optimotu_pipeline_fasta_combine`, infiles, outfile, compress)
}

#' @describeIn fastx_rename Rename reads in a FASTQ file
#' @param infile (`character`) FAST(A/Q) file path, optionally gzipped.
#' @param names (`character`) New read names.
#' @param outfile (`character`) FAST(A/Q) file path, optionally gzipped.
#' @return (`character`) Output file path.
#' @export
fastq_rename <- function(infile, names, outfile) {
    .Call(`_optimotu_pipeline_fastq_rename`, infile, names, outfile)
}

#' @describeIn fastx_rename Rename reads in a FASTA file
#' @export
fasta_rename <- function(infile, names, outfile) {
    .Call(`_optimotu_pipeline_fasta_rename`, infile, names, outfile)
}

#' Split a FASTQ file into multiple files
#' @param infile Input FASTQ file
#' @param outfiles Output FASTQ files
#' @param compress Whether to compress the output files
#' @return Output file names
#' @export
#' @keywords internal
fastq_split <- function(infile, outfiles, compress = FALSE) {
    .Call(`_optimotu_pipeline_fastq_split`, infile, outfiles, compress)
}

#' Split a FASTA file into multiple files
#' @param infile Input FASTA file
#' @param outfiles Output FASTA files
#' @param compress Whether to compress the output files
#' @return Output file names
#' @export
#' @keywords internal
fasta_split <- function(infile, outfiles, compress = FALSE) {
    .Call(`_optimotu_pipeline_fasta_split`, infile, outfiles, compress)
}

