% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lulu_long.R
\name{lulu_map}
\alias{lulu_map}
\title{LULU secondary denoising}
\usage{
lulu_map(
  otu_table,
  match_table,
  max_dist = lulu_max_dist(),
  min_abundance_ratio = lulu_min_abundance_ratio(),
  min_cooccurrence_ratio = lulu_min_cooccurrence_ratio(),
  use_mean_abundance_ratio = lulu_use_mean_abundance_ratio(),
  id_is_int = "seq_idx" \%in\% names(otu_table),
  id_is_sorted = id_is_int,
  verbose = 0
)
}
\arguments{
\item{otu_table}{(\code{data.frame}) the long-format table to denoise. Must have
columns \code{seq_id} (\code{character}) xor \code{seq_idx} (\code{integer}), as well as
\code{nread} (\code{integer}). Additional columns such as the sample id or metadata are
allowed but ignored.}

\item{match_table}{(\code{data.frame}) table of pairwise matches between
co-occuring OTUs. Must have columns \code{seq_id1}and \code{seq_id2} (both \code{character})
xor \code{seq_idx1} and \code{seq_idx2} (both \code{integer}), as well as \code{nread1} and
\code{nread2} (\code{integer}) and \code{dist} (\code{numeric}). Additional columns are ignored.}

\item{max_dist}{(\code{numeric} scalar) maximum pairwise distance for two OTUs to
be considered for merging. This may be given as a percentage between 0 and
100, as a fraction between 0.0 and 1.0, or any other non-negative scale, but
should be on the same scale as the values of \code{dist} in \code{match_table}.
Default: \code{0.1} (intended as a fraction).}

\item{min_abundance_ratio}{(\code{numeric} scalar) minimum ratio of
"parent":"daughter" abundances for two OTUs to be considered for merging.
The exact meaning is dependent on the value of \code{use_mean_abundance_ratio}.
Default: \code{1}.}

\item{min_cooccurrence_ratio}{(\code{numeric} scalar) minimum ratio of
co-occurrences to total occurrences of the "daughter" for two OTUs to be
considered for merging. Default: \code{1}.}

\item{use_mean_abundance_ratio}{(\code{logical} flag) if \code{TRUE},
\code{min_abundance_ratio} refers to the mean of the relative abundances between
the "parent" and "daughter" sequences in all samples where they co-occur. If
\code{FALSE}, the minimum is enforced for every sample. Default: \code{FALSE}.}

\item{id_is_int}{(\code{logical} flag) if \code{TRUE}, the OTU identifiers are
integers; in this case they are expected to be in columns \verb{seq_idx*}. If
\code{FALSE}, the OTU identifiers are character strings, and are expected to be
in columns \verb{seq_id*}. Default: \code{TRUE} if \code{otu_table} has a column \code{seq_idx},
\code{FALSE} otherwise.}

\item{id_is_sorted}{(\code{logical} flag) if \code{TRUE}, the values of \verb{seq_id*} or
\verb{seq_idx*} are sorted in decreasing order of prevalence (number of samples),
with ties broken by decreasing total abundance (\code{nread}). This skips the
computational cost of sorting the OTUs, but will cause an error if they are
not sorted as described. Default: \code{TRUE} if \code{id_is_int} is \code{TRUE}, otherwise
\code{FALSE}.}

\item{verbose}{(\code{integer} scalar) level of verbosity for progress messages.}
}
\value{
a two-column \code{data.frame} with columns \code{seq_idx} and \code{lulu_idx}
or \code{seq_id} and \code{lulu_id}. \verb{seq_id*} includes all values which occur in
\code{otu_table}, and \verb{lulu_id*} gives the corresponding value in \code{lulu_table};
these differ only for sequences which were determined to be minor variants
of another sequence.
}
\description{
The LULU algorithm is described by Frøslev et al. (2017) and implemented in
lulu::lulu()`.  This is an independent implementation of the algorithm as
described in that paper, adapted to work with long-format OTU tables. It also
assumes that the match table was generated on a per-sample basis.  This means
that there should be multiple entries for each pair of co-occurring OTUs if
they co-occur in multiple samples.  Although it may seem that this means
that the match list and the computation required to generate it are larger
than necessary, it is in fact smaller and more efficient in most cases,
because the majority of OTU pairs do not co-occur in any samples, and so
there is no need to compute or store their distances. Additionally computing
the distances sample-wise allows easy parallelization of that step.
}
\details{
There is a \href{https://github.com/tobiasgf/lulu/issues/8}{longstanding issue}
in the original LULU implementation which prevents it from actually
identifying "daughter" sequences when they occur less than 100\% of the time
with their "parent" sequence, even though the default value for
\code{min_cooccurrence} is 0.95. This implementation, like
\href{https://github.com/frederic-mahe/mumu}{mumu}, implements the algorithm as
described rather than as implemented in \code{lulu::lulu()}, but other than this
it is tested to give identical results to \code{lulu::lulu()} when run on the same
data.

This function implements only the core LULU algorithm, meaning it determines
which OTUs are to be merged.  The actual merging of the OTU table is then
performed by \code{lulu_table()}.  Like the original implementation, calculating
pairwise distances is left to the user, e.g. using BLAST, USEARCH, VSEARCH,
etc. \link[optimotu:seq_distmx]{optimotu::seq_distmx} is also a convenient way.
}
\references{
Frøslev, T. G., Kjøller, R., Bruun, H. H., Ejrnæs, R., Brunbjerg,
A. K., Pietroni, C., & Hansen, A. J. (2017). Algorithm for post-clustering
curation of DNA amplicon data yields reliable biodiversity estimates.
Nature Communications, 8(1), 1188.
\url{https://www.nature.com/articles/s41467-017-01312-x}
}
